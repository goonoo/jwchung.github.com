---
layout: post
tags : [TestCommon]
---
{% include JB/setup %}

지금 이 글을 읽으시는 분께서 얼마나 [TDD][](Test-Driven Development) 관심이 있으시고,
개발과정에서 얼마나 [TDD][]를 활용하시는지 잘 모르겠습니다.
제가 여기서 소개해 드리려고 하는 것은 단위테스트를 *'어떻게 하면 효율적으로 할 수 있을까에 대한 것'*입니다.
여기서 효율적이란 말은 *'단위 테스트는 무엇을 테스트하느냐에만 집중해야 한다'*라고 설명할 수 있겠습니다.
아래의 예제에서 좀 더 자세히 살펴보도록 하겠습니다.

예제를 살펴보기에 앞서, 제가 여기서 사용한 테스트프레임워크는 [Xunit][]입니다.
아마 Visual Studio에 자체적으로 제공되는 MSTest를 사용하시는 분도 계실 테고,
널리 알려진 [NUnit][]이라는 테스트프레임워크를 사용하시는 분도 계실 것입니다.
[Xunit][]는 여타의 테스트프레임워크들과 크게 다르지 않습니다.
차이점은 [여기][Comparisons]에서 확인하실 수 있습니다.

먼저 아래와 같은 `Pizza` 클래스가 있다고 가정합시다.

```c#
public class Pizza
{
	public string Name { get; private set; }

	public int Price { get; private set; }

	public Pizza(string name, int price)
	{
		Name = name;
		Price = price;
	}
}
```

아래의 `AddMenu_WithValidPizza_SavesThePizza()`라는 단위테스트는 `PizzaStore` 클래스의 `AddMenu(Pizza)` 메소드를 테스트하기 위한 것입니다.
아래 코드에서 보듯이, `AddMenu(Pizza)` 메소드는 아무개피자를 메뉴에 등록하는 역할을 합니다.
이때 `anonymousPizza` 객체의 이름과 가격은(`name: "anonymous", price: 100`) 이 테스트에서 아무런 역할도 하고 있지 않지만
값을 명기하여야지만 `Pizza` 타입의 객체가 생성됩니다. 이는 테스트코드를 이해하는 데 지장만 초래합니다.
`name: "anonymous"`의 경우는 그 값을 `"anonymous"`로 하여 아무개란 의미를 부여할 수 있지만,
`price: 100`의 경우는 `100`이라는 값이 이 단위테스트에 영향을 주는 것으로 오해할 수도 있습니다.

```c#
[Fact]
public void AddMenu_WithValidPizza_SavesThePizza()
{
	// Arrange
	var menus = new List<Pizza>();

	var sut = new PizzaStore(menus);

	var anonymousPizza = new Pizza(name: "anonymous", price: 100);

	// Act
	sut.AddMenu(anonymousPizza);

	// Assert
	Assert.Equal(1, menus.Count);
	Assert.Same(anonymousPizza, menus[0]);
}
```

이를 해결하기 위해서는 `Pizza` 타입의 객체를 생성하는 `CreateAnonymousPizza()`와 같은 Helper 메소드를 만들어
아래와 같은 코딩을 해야 할 것입니다. `CreateAnonymousPizza()`는 `Pizza` 타입의 불필요한 정보(이름, 가격)는 숨기는 대신
`CreateAnonymousPizza`라는 이름에서 어떤 역할의 메소드이지 그 의도를 명확히 담고 있습니다.
이로써 위에서 본 테스트 보다 아래의 테스트가 앞서 말한 효율적 측면에서 진일보한 것으로 볼 수 있습니다.

```c#
[Fact]
public void AddMenu_WithValidPizza_SavesThePizza()
{
	// Arrange
	var menus = new List<Pizza>();

	var sut = new PizzaStore(menus);

	var anonymousPizza = CreateAnonymousPizza();

	// Act
	sut.AddMenu(anonymousPizza);

	// Assert
	Assert.Equal(1, menus.Count);
	Assert.Same(anonymousPizza, menus[0]);
}

public void CreateAnonymousPizza()
{
	return new Pizza(name: "anonymous", price: 100);
}
```

아래 코드는 위 테스트코드를 만족하게 하는 `PizzaStore` 클래스입니다.

```c#
public class PizzaStore
{
	private readonly ICollection<Pizza> _menus;

	public PizzaStore(ICollection<Pizza> menus)
	{
		_menus = menus;
	}

	public void AddMenu(Pizza pizza)
	{
		_menus.Add(pizza);
	}
}
```

위 예제처럼 단위테스트에 불필요한 정보를 제외하고 무엇을 테스트하느냐에만 집중하는 것은 테스트를 작성한 사람뿐만 아니라
이 테스트를 보는 모든 사람에게 좀 더 명확한 정보를 제공할 수 있습니다.
하지만 문제는 단위테스트에서 필요한 아무개객체 타입마다 `CreateAnonymousPizza()`와 같은 메소드를 만든다는 것은 여간 귀찮은 작업이 아닐 수 없습니다.

이 문제에 대한 도움을 주는 프레임워크가 있습니다. 바로 [AutoFixture][]라는 것입니다. 물론 .net으로 된 오픈소스입니다.
[AutoFixture][]는 꽤 오랜 시간 동안 개발이 이루어져 왔고 [Statckoverflow][] Q&A사이트에서도 이에 대한 질문이 꽤 나오는 것을 보면
사용하는 사람이 어느 정도인가를 짐작해 볼 수 있습니다.

저도 처음에는 [AutoFixture][]를 사용하였지만, 제게는 불편한 점이 몇 있었습니다.
가장 크게 불편했던 점은 [AutoFixture][]에서는 [Freeze][]란 기능으로 생성자에 특정 파라메터를 넘기는 것이었습니다.
[Freeze][]로 얼려진 아무개객체는 그 타입의 다른 아무개객체에 모두 같은 값을 부여하게 되어 제게는 혼란을 가져다주었습니다.
그래서 이를 해결하고 테스트에 필요한 기능을 추가하여 [TestCommon][]이라는 프레임워크를 만들게 되었습니다.
물론 아직 미흡한 점이 많을 것입니다. 앞으로 개선 발전시켜 나갈 예정입니다.

TestCommon
----------
그럼 단위테스트 `AddMenu_WithValidPizza_SavesThePizza()`에 [TestCommon][]를 도입해 보면 아래 코드와 같습니다.
아래 코드에서는 [TestCommon][]사용으로 `anonymousPizza`객체 뿐 아니라 모든 객체생성과정에서 앞서와 같은 불필요한 정보제공의 문제를 해결할 수 있습니다.
이때, `sut`객체와 `anonymousPizza`객체 생성에서는 큰 차이점이 하나 존재합니다.
`anonymousPizza`객체는 `Pizza`의 모든 attriutes(fields 또는 proproperties)가 어떠한 값이든지 상관이 없습니다.
그러나, `sut`객체는 특정한 `menus`객체를 생성자 파라메터로 넘겨받아야만 합니다.
이를 위해, [TestCommon][]에서 `Inject(...)`란 메소드들을 제공하고 있습니다.

`Inject(...)` 메소드 사용으로 얻을 수 있는 이점은
`PizzaStore`의 생성자 `ctor(ICollection<Pizza>)`에 다른 파라메터를 추가하더라도 기존 작성된 단위테스트들은 전혀 영향을 받지 않는다는 것입니다.
더 자세한 내용은 [TestCommon Wiki][]를 참고하시길 바랍니다.

아래 코드에서 `ICollection<Pizza>`타입의 `menus` 객체는 디폴트로 3개의 `Pizza`객체를 가지게 됩니다. 그래서 새로 추가되는 피자메뉴는
4번째 메뉴가 됩니다.

```c#
[Fact]
public void ForFixture_AddMenu_WithValidPizza_SavesMenuForThePizza()
{
	// Arrange
	var fixture = new Fixture();

	var menus = fixture.CreateAnonymous<ICollection<Pizza>>();

	var sut = fixture.Build<PizzaStore>()
		.Inject(menus)
		.CreateAnonymous();

	var anonymousPizza = fixture.CreateAnonymous<Pizza>();

	// Act
	sut.AddMenu(anonymousPizza);

	// Assert
	Assert.Equal(4, menus.Count);
	Assert.Same(anonymousPizza, menus.ElementAt(3));
}
```

FactsAttribute사용
------------------
`FactsAttribute`를 사용하면 위 `ForFixture_AddMenu_WithValidPizza_SavesMenuForThePizza()` 단위테스트 메소드에서 아래 코드와 같이
아무개객체(`menu`, `anonymousPizza`)를 테스트메소드 파라메터로 넘겨받을 수 있습니다. `PizzaStore`객체와 같이 생성자에서 특정 파라메터를
취하거나 프라퍼티를 통해 특정객체를 입력받는 게 필요하다면 `ISpecimenBuilder<T>` 타입의 객체를 메소드 파라메터로 넘겨받아 특정 `T`타입의 객체를
빌드할 수 있습니다. 이렇게 함으로써 앞서 [TestCommon][]을 도입하기 전의 테스트메소드 `AddMenu_WithValidPizza_SavesThePizza()` 보다
효율적이면서 코드량도 상당히 줄일 수 있습니다.

`FactsAttribute`는 [Xunit][]의 `FactAttribute`를 상속한 것으로 `FactAttribute`가지는 테스트 어트리뷰트 특성을 모두 가지면서
아래와 같은 아무개객체를 생성하는 기능을 동시에 제공할 수 있습니다.

```c#
[Facts]
public void ForFactsAttribute_AddMenu_WithValidPizza_SavesMenuForThePizza(
	ICollection<Pizza> menus, 
	ISpecimenBuilder<PizzaStore> sutBuilder, 
	Pizza anonymousPizza)
{
	// Arrange
	var sut = sutBuilder.Inject(menus).CreateAnonymous();

	// Act
	sut.AddMenu(anonymousPizza);

	// Assert
	Assert.Equal(4, menus.Count);
	Assert.Same(anonymousPizza, menus.ElementAt(3));
}
```

또한, 아래 코드와 같이 [Xunit][]의 `DataAttibutes`에서 파생된 클래스들(여기에서는 `InlineDataAttribute`)과 결합하여
`DataAttibutes`에서 명시된 값들은 테스트 메소드의 파라메터에서 앞부분에 먼저 매칭이 되고 그리고 나머지의 것들에 대해서
[TestCommon]에서는 아무개 객체를 제공하게 됩니다.

```c#
[Facts]
[InlineData("anonymous")]
public void AnonymousCreationWithDataAttribute(string anonymousStrnig, Pizza anonymousPizza)
{
	Assert.Equal("anonymous", anonymousStrnig);
	Assert.NotNull(anonymousPizza);
}
```

How to Install
--------------
[TestCommon][]은 [nuget][TestCommon Nuget]에 등록이 되어 있습니다. Visual Studio에서 nuget manager를 설치하셨다면
"TestCommon"이라는 이름으로 검색하고 Install할 수 있습니다.

끝으로
------
여기서는 소개하지 않았지만 [TestCommon][]는 [Moq][]프레임워크를 통하여 인스턴스화 될 수 없는 인터페이스, 추상클래스에 대해서도
아무개객체를 생성할 수 있습니다.
더 자세한 내용은 [TestCommon Wiki][]를 참고하시거나, [Acceptance Test][]의 코드를 통해서도 실제 사용법을 알아보실 수 있습니다.

전체소스는 다음 중 하나의 방법으로 다운받을 수 있습니다.
* [TestCommon][]의 [태그페이지][tags]에서 버전별 전체소스를 다운받으실 수 있습니다
* github의 [fork][fork-a-repo]기능을 이용할 수 있습니다.
* git clone 명령을 이용할 수 있습니다.

        git clone git@github.com:jwJung/TestCommon.git


[TDD]: http://en.wikipedia.org/wiki/Test-driven_development
[Comparisons]: http://xunit.codeplex.com/wikipage?title=Comparisons
[Xunit]: http://xunit.codeplex.com/
[NUnit]: http://www.nunit.org/
[AutoFixture]: https://github.com/AutoFixture/AutoFixture
[StatckOverflow]: http://stackoverflow.com/
[TestCommon]: https://github.com/jwJung/TestCommon
[Freeze]: http://blog.ploeh.dk/2010/03/17/AutoFixtureFreeze.aspx
[TestCommon Wiki]: https://github.com/jwJung/TestCommon/wiki
[Acceptance Test]: https://github.com/jwJung/TestCommon/tree/master/test/TestCommon.AcceptanceTest
[TestCommon Nuget]: https://nuget.org/packages/TestCommon
[Moq]: http://code.google.com/p/moq/
[tags]: https://github.com/jwJung/TestCommon/tags
[fork-a-repo]: https://help.github.com/articles/fork-a-repo