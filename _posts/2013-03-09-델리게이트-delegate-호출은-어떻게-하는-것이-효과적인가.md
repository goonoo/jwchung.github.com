---
layout: post
title: 델리게이트(delegate) 호출은 어떻게 하는 것이 효과적인가?
tags : [C# General]
cc: ko
---
{% include JB/setup %}

### <a id="서론"></a>서론
[훈스닷넷의 한 질문글]에서 **Lookvv**라는 분이 윈폼의 `Control.Invoke(Delegate)`메소드에 대해 아래와 같이 답한 내용을 보고

> 하지만 msdn에 MethodInvoker 델리게이트가 퍼포먼스에 더 좋다고 명시되어있기 때문에
> 보통 MethodInvoker란 델리게이트를 사용합니다. 더 빠르다고 하는데 안할 이유가 없죠.

[MSDN]을 살펴보니 다음과 같은 내용이 있었다.

> A call to an EventHandler or MethodInvoker delegate will be faster than a call to another type of delegate.

`EventHandler`, `MethodInvoker` 타입의 델리게이트가 파라메타로 전달되었을 때 왜 더 빠를까?라는 의문이 생겼다.
이와 관련한 .NET Framework의 `Control` class 소스 일부를 살펴보면 아래와 같다. `Control.Invoke`를 실행하면 아래의
`Control.InvokeMarshaledCallbackDo`메소드를 호출하게 되는데, 이때 아래의 `tme.method` 델리게이트가 `EventHandler`타입인지 `MethodInvoker` 타입인지 확인하게 된다. 

따라서 `Control.Invoke`메소드의 파라메타로 `EventHandler` 또는 `MethodInvoker` 타입의 델리게이트이면
델리게이트를 직접 호출하게 되며, 그 이외의 델리게이트는 `Delegate.DynamicInvoke`메소드를 호출하게 된다. 델리게이트를 직접 호출하는 것은 `Delegate.Invoke`를 호출하게 됨으로
결국, `Delegate.Invoke`와 `Delegate.DynamicInvoke`의 성능차이 때문에 [MSDN]에서는 위와 같이 언급한 것이다.

```c#
// .NET Framework의 Control.cs 소스의 일부분 입니다.

private static void InvokeMarshaledCallbackDo(ThreadMethodEntry tme) 
{
    // We short-circuit a couple of common cases for speed. 
    //
    if (tme.method is EventHandler) {
        if (tme.args == null || tme.args.Length < 1) {
            ((EventHandler)tme.method)(tme.caller, EventArgs.Empty); 
        }
        else if (tme.args.Length < 2) { 
            ((EventHandler)tme.method)(tme.args[0], EventArgs.Empty); 
        }
        else { 
            ((EventHandler)tme.method)(tme.args[0], (EventArgs)tme.args[1]);
        }
    }
    else if (tme.method is MethodInvoker) { 
        ((MethodInvoker)tme.method)();
    } 
    else if (tme.method is WaitCallback) 
    {
        Debug.Assert(tme.args.Length == 1, 
                     "Arguments are wrong for WaitCallback");
        ((WaitCallback)tme.method)(tme.args[0]);
    }
    else { 
        tme.retVal = tme.method.DynamicInvoke(tme.args);
    } 
} 
```

그럼 과연 `Delegate.Invoke`와 `Delegate.DynamicInvoke`의 성능차이는 어느 정도일까?
막연히 `Delegate.Invoke`가 당연히 빠르다라고만 생각을 했었지 어느 정도인가는 그 동안 직접 확인하지 못 했었다.

<!-- break -->

### <a id="Delegate.Invoke vs Delegate.DynamicInvoke"></a>Delegate.Invoke vs Delegate.DynamicInvoke
먼저 성능을 알아보기 위해 아래와 같은 스톱워치 클래스를 만들었다.

```c#
public class TestStopwatch : IDisposable
{
    private readonly Stopwatch _stopwatch;

    private TestStopwatch()
    {
        _stopwatch = new Stopwatch();
        _stopwatch.Start();
    }

    public static TestStopwatch Start()
    {
        return new TestStopwatch();
    }

    public void Dispose()
    {
        _stopwatch.Stop();
        Console.WriteLine(_stopwatch.ElapsedMilliseconds);
    }
}
```

아래는 `Delegate`를 어떻게 실행하느냐에 따른 성능 테스트를 위한 코드이다.
델리게이트를 어떻게 실행하느냐를 다음과 같이 5가지로 나눠 살펴보았다.

 1. 델리게이트 직접실행
 2. Invoke
 3. 델리게이트의 해당 MethodInfo를 실행
 4. 델리게이트의 Invoke메소드를 리플렉션을 통한 실행
 5. DynamicInvoke

위 5가지는 다시 크게 두 가지로 나눌 수 있다. 런타임시 델리게이트의 실제 타입을 요하는 1, 2번 경우와
런타임시 델리게이트의 실제 타입을 요하지 않는 3, 4, 5번 경우(동적 델리게이트 호출)로 나눌 수 있다.

델리게이트는 특정 메소드의 랩퍼로 이해될 수 있는데 델리게이트 객체는
`MethodInfo`타입의 `Method`프라퍼티와 그 특정 메소드를 소유하는 객체인 `Target`프라퍼티를 가진다.
델리게이트가 실행되면 델리게이터 내부의 `Invoke`메소드를 실행하게 되는데 이를 리플렉션으로 표현한 것이 4번 경우이다.
3번 경우는 `MethodInfo`를 통하여 특정 메소드를 리플렉션으로 실행하는 것을 보여주고 있다.

```c#
public class DelegatePerformanceTest
{
    private const int IterationCount = 10000000;

    private readonly Action _testAction = () => { };

    [Fact]
    public void ExecuteDelegate_Invoke_IsFast()
    {
        using (TestStopwatch.Start())
        {
            for (int i = 0; i < IterationCount; i++)
            {
                _testAction();
            }
        }
    }

    [Fact]
    public void ExecuteDelegate_InvokeDelegate_IsFast()
    {
        using (TestStopwatch.Start())
        {
            for (int i = 0; i < IterationCount; i++)
            {
                _testAction.Invoke();
            }
        }
    }

    [Fact]
    public void ExecuteDelegate_InvokeMethodInfo_IsSlow()
    {
        using (TestStopwatch.Start())
        {
            for (int i = 0; i < IterationCount; i++)
            {
                _testAction.Method.Invoke(_testAction.Target, null);
            }
        }
    }

    [Fact]
    public void ExecuteDelegate_InvokeMethodInfoOfDelegate_IsSlow()
    {
        using (TestStopwatch.Start())
        {
            var delegateInvokeMethod = _testAction.GetType().GetMethod("Invoke");

            for (int i = 0; i < IterationCount; i++)
            {
                delegateInvokeMethod.Invoke(_testAction, null);
            }
        }
    }

    [Fact]
    public void ExecuteDelegate_DynamicInvoke_IsVerySlow()
    {
        using (TestStopwatch.Start())
        {
            for (int i = 0; i < IterationCount; i++)
            {
                _testAction.DynamicInvoke();
            }
        }
    }
}
```

아래는 위 코드에 대한 결과이다(결과 단위=밀리초). 물론 컴퓨터 환경에 따라 아래의 결과는 달라지겠지만 상대적 차이로 성능 차이를 짐작할 수 있을 것이다.
정확한 타입을 요하는 1, 2번 경우가 다른 경우들에 비해 월등히 빠른 것을 알 수 있다. 이 말은 델리게이트의 정확한 타입을 알고 있을 경우
`Invoke`를 통하여 호출하지 않을 이유가 없다는 것이다. 1, 2번 둘의 차이는 큰 의미가 없다. 1번의 호출의 경우 내부적으로 2번의 `Invoke` 메소드를 호출하게 된다.

3, 4번 경우는 5번 경우보다는 2배 이상의 성능을 보여주고 있다.
델리게이트를 동적으로 호출해야할 경우(3~5번 중) 5번의 경우는 비효과적으로 보인다.
그렇다면 **DynamicInvoke는 언제 사용하여야 할까?**
[서론](#서론)에서 언급한 **Control.Invoke는 위의 3, 4번과 같이 호출하면 더 효과적이지 않을까?**

```
1. DelegatePerformanceTest.ExecuteDelegate_Invoke_IsFast:                          55

2. DelegatePerformanceTest.ExecuteDelegate_InvokeDelegate_IsFast:                  52

3. DelegatePerformanceTest.ExecuteDelegate_InvokeMethodInfo_IsSlow:              2198

4. DelegatePerformanceTest.ExecuteDelegate_InvokeMethodInfoOfDelegate_IsSlow:    2245

5. DelegatePerformanceTest.ExecuteDelegate_DynamicInvoke_IsVerySlow:             5357
```

### <a id="Delegate.DynamicInvoke는 언제 사용하는가?"></a>Delegate.DynamicInvoke는 언제 사용하는가?
한 가지 간과해서는 안되는 사실이 `Delegate`는 내부적으로 [Composite 패턴]을 구현하고 있다는 사실이다.
델리게이트가 실행해야할 메소드를 여러 개 가지고 있을 경우 위의 3번의 경우는 제일 마지막에 등록된 메소드만을
실행하게 된다. 아래 코드에서 확인할 수 있다.

```c#
public class DelegateTest
{
    [Fact]
    public void ExecuteDelegate_Invoke_CallsAllMethods()
    {
        // Arrange
        var callSequence = new List<int>();

        Action action = null;
        action += () => callSequence.Add(0);
        action += () => callSequence.Add(1);

        // Act
        action();

        // Assert
        Assert.Equal(new[] { 0, 1 }, callSequence);
    }

    [Fact]
    public void ExecuteDelegate_InvokeMethodInfo_CallsOnlyLastMethod()
    {
        // Arrange
        var callSequence = new List<int>();

        Action action = null;
        action += () => callSequence.Add(0);
        action += () => callSequence.Add(1);
        action += () => callSequence.Add(2);

        // Act
        action.Method.Invoke(action.Target, null);

        // Assert
        Assert.Equal(new[] { 2 }, callSequence);
    }
}
```
즉, 앞서 '3, 4번 경우가 5번 `DynamicInvoke`를 호출 경우보다 효과적이다'라고 말할 수 있는 것은 테스트 대상 델리게이트가 메소드를
하나만 가지고 있을 경우였다.
여러 개의 메소드를 가지는 델리게이트를 아래와 같이 테스트 해 보았다.

```c#
public class DelegateWithSeveralMethodsPerformanceTest
{
    private const int IterationCount = 3000000;

    private readonly Action _testAction;
    private int _callCount;

    public DelegateWithSeveralMethodsPerformanceTest()
    {
        _testAction += () => _callCount++;
        _testAction += () => _callCount++;
        _testAction += () => _callCount++;
        _testAction += () => _callCount++;
        _testAction += () => _callCount++;
    }

    [Fact]
    public void ExecuteDelegate_Invoke_IsFast()
    {
        using (TestStopwatch.Start())
        {
            for (int i = 0; i < IterationCount; i++)
            {
                _testAction();
            }
        }

        Assert.Equal(_testAction.GetInvocationList().Length * IterationCount, _callCount);
    }

    [Fact]
    public void ExecuteDelegate_InvokeMethodInfo_IsSlow()
    {
        using (TestStopwatch.Start())
        {
            var delegates = _testAction.GetInvocationList();
            for (int i = 0; i < IterationCount; i++)
            {
                foreach (var @delegate in delegates)
                {
                    @delegate.Method.Invoke(@delegate.Target, null);
                }
            }
        }

        Assert.Equal(_testAction.GetInvocationList().Length * IterationCount, _callCount);
    }

    [Fact]
    public void ExecuteDelegate_DynamicInvoke_IsSlow()
    {
        using (TestStopwatch.Start())
        {
            for (int i = 0; i < IterationCount; i++)
            {
                _testAction.DynamicInvoke();
            }
        }

        Assert.Equal(_testAction.GetInvocationList().Length * IterationCount, _callCount);
    }
}
```

결과는 아래와 같다.
그렇다 델리게이트가 여러 개의 메소드를 가지고 있을 경우 `DynamicInvoke`가
모든 `MethodInfo`를 위와 같이 실행하는 것 보다 효과적이었다.

```
DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_Invoke_IsFast:              175

DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_InvokeMethodInfo_IsSlow:   3969

DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_DynamicInvoke_IsSlow:      1722
```

물론 아래와 같이 나머지 실행 메소드를 주석처리하고 델리게이터가 하나의 메소드만 가지면
`MethodInfo`를 실행하는 경우가 `DynamicInvoke`를 실행하는 경우보다 더 빨랐다.

```c#
public DelegateWithSeveralMethodsPerformanceTest()
{
    _testAction += () => _callCount++;
    //_testAction += () => _callCount++;
    //_testAction += () => _callCount++;
    //_testAction += () => _callCount++;
    //_testAction += () => _callCount++;
}
```

```
DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_Invoke_IsFast:               33

DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_InvokeMethodInfo_IsSlow:    738

DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_DynamicInvoke_IsSlow:      1580
```

실행 메소드가 두 개일 경우는 아래 결과와 같이 두 실행 방법(`MethodInfo` vs `DynamicInvoke`)은 큰 차이를 보이지 않았다.
물론 **모든 경우에서 실행 메소드가 두개일 경우 비슷한 성능을 보인다**라고 절대 말할 수 없다.

```
DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_Invoke_IsFast:               57

DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_InvokeMethodInfo_IsSlow:   1568

DelegateWithSeveralMethodsPerformanceTest.ExecuteDelegate_DynamicInvoke_IsSlow:      1623
```

### <a id="결론"></a>결론
앞서의 테스트들 결과를 토대로 유추할 수 있는 것은

*   델리게이트 타입을 알고 있는 경우  
    \- 델리게이트를 직접실행 혹은 `Invoke`를 호출하는 것이 효과적(비동기식 호출은 논외)

*   동적으로 델리게이트를 실행할 경우  
    \- 실행해야할 메소드가 하나라고 확신하는 경우: `Delegate.MethodInfo.Invoke`를 호출  
    \- 실행해야할 메소드가 하나라고 확신하지 못하는 경우: `Delegate.DynamicInvoke`를 호출

사실 경험에 비추어 보면 델리게이트는 하나의 메소드만 가지는 것이 대부분이었다.
하지만 무조건이라고 확신할 수 없기 때문에 아래와 같이 디버그모드에서만 실행되는 Assertion을 추가하는 것도 하나의 방법이라 생각된다.

```c#
Debug.Assert(action.GetInvocationList().Length == 1);
```

추가적으로 윈폼의 `Control.Invoke`를 실행해야 할 경우
`EventHandler` 또는 `MethodInvoker`타입의 델리게이트를 넘겨주는 것이 효과적이므로 다음과 같은 Extensions 클래스를 생각해 볼 수 있다.

```c#
public static class ControlInvokeExtensions
{
    public static void InvokeWithEventHandler(
        this Control control, EventHandler eventHandler)
    {
        control.Invoke(eventHandler);
    }

    public static void InvokeWithMethodInvoker(
        this Control control, MethodInvoker methodInvoker)
    {
        control.Invoke(methodInvoker);
    }
}
```

[훈스닷넷의 한 질문글]: <http://www.hoons.net/Board/qacshap/Content/57752/#dvComment211025>
[MSDN]: <http://msdn.microsoft.com/en-us/library/zyzhdc6b.aspx>
[Composite 패턴]: <http://ko.wikipedia.org/wiki/%EC%BB%B4%ED%8F%AC%EC%A7%80%ED%8A%B8_%ED%8C%A8%ED%84%B4>